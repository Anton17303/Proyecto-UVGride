const http = require('http');
const https = require('https');
const { URL } = require('url');
const { performance } = require('perf_hooks');

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function percentile(values, p) {
  if (values.length === 0) return 0;
  const sorted = [...values].sort((a, b) => a - b);
  const index = Math.min(sorted.length - 1, Math.floor((p / 100) * (sorted.length - 1)));
  return sorted[index];
}

function httpRequest(url, options = {}) {
  const target = new URL(url);
  const client = target.protocol === 'https:' ? https : http;

  return new Promise((resolve, reject) => {
    const request = client.request(
      target,
      {
        method: options.method || 'GET',
        headers: options.headers,
        timeout: options.timeout || 30000,
      },
      (response) => {
        const chunks = [];
        response.on('data', (chunk) => chunks.push(chunk));
        response.on('end', () => {
          resolve({
            status: response.statusCode,
            ok: response.statusCode >= 200 && response.statusCode < 300,
            body: Buffer.concat(chunks),
          });
        });
      }
    );

    request.on('error', reject);
    request.on('timeout', () => {
      request.destroy(new Error('timeout'));
    });

    if (options.body) {
      request.write(options.body);
    }

    request.end();
  });
}

async function runScenario({ name, baseUrl, paths, durationSeconds, concurrency }) {
  console.log(`\nüöÄ Escenario: ${name}`);
  console.log(`   Concurrencia: ${concurrency} | Duraci√≥n: ${durationSeconds}s`);

  const latencies = [];
  let totalRequests = 0;
  let totalErrors = 0;

  const endAt = Date.now() + durationSeconds * 1000;
  const waitBetweenBatches = Number(process.env.FRONTEND_REQUEST_PAUSE_MS || 0);

  async function worker(id) {
    let iteration = 0;
    while (Date.now() < endAt) {
      for (const path of paths) {
        const url = `${baseUrl}${path}`;
        const start = performance.now();
        try {
          const response = await httpRequest(url, { method: 'GET' });
          const latency = performance.now() - start;
          latencies.push(latency);
          totalRequests += 1;
          if (!response.ok) {
            totalErrors += 1;
            console.warn(`   ‚ö†Ô∏è  Respuesta no OK (${response.status}) para ${url}`);
          }
        } catch (error) {
          totalErrors += 1;
          console.warn(`   ‚ö†Ô∏è  Error en ${url}: ${error.message}`);
        }
      }

      iteration += 1;
      if (iteration % 10 === 0) {
        console.log(`   Worker ${id}: ${iteration} iteraciones completadas`);
      }

      if (waitBetweenBatches > 0) {
        await sleep(waitBetweenBatches);
      }
    }
  }

  await Promise.all(Array.from({ length: concurrency }, (_, index) => worker(index + 1)));

  const avgLatency = latencies.reduce((acc, cur) => acc + cur, 0) / (latencies.length || 1);

  console.log(`‚úÖ Resultados escenario: ${name}`);
  console.table({
    peticiones: totalRequests,
    errores: totalErrors,
    'latencia media (ms)': avgLatency.toFixed(2),
    'p95 (ms)': percentile(latencies, 95).toFixed(2),
    'p99 (ms)': percentile(latencies, 99).toFixed(2),
  });
}

async function main() {
  const baseUrl = process.env.FRONTEND_BASE_URL || 'http://localhost:19006';
  const pathsEnv = process.env.FRONTEND_PATHS || '/';
  const assetEnv = process.env.FRONTEND_ASSETS || '';
  const mainPaths = pathsEnv.split(',').map((p) => p.trim()).filter(Boolean);
  if (mainPaths.length === 0) {
    console.warn("   ‚ö†Ô∏è  No se definieron rutas principales, se usar√° '/' por defecto.");
    mainPaths.push('/');
  }
  const assetPaths = assetEnv
    .split(',')
    .map((p) => p.trim())
    .filter(Boolean);

  console.log('üèÅ Iniciando pruebas de estr√©s para el frontend');
  console.log(`   Base URL: ${baseUrl}`);
  console.log(`   Rutas principales: ${mainPaths.join(', ') || '(ninguna)'}`);
  if (assetPaths.length > 0) {
    console.log(`   Recursos est√°ticos: ${assetPaths.join(', ')}`);
  }

  const scenarios = [
    {
      name: 'Pantalla principal',
      baseUrl,
      durationSeconds: Number(process.env.FRONTEND_MAIN_DURATION || 60),
      concurrency: Number(process.env.FRONTEND_MAIN_CONNECTIONS || 15),
      paths: mainPaths,
    },
  ];

  if (assetPaths.length > 0) {
    scenarios.push({
      name: 'Recursos est√°ticos',
      baseUrl,
      durationSeconds: Number(process.env.FRONTEND_ASSETS_DURATION || 45),
      concurrency: Number(process.env.FRONTEND_ASSETS_CONNECTIONS || 10),
      paths: assetPaths,
    });
  }

  for (const scenario of scenarios) {
    await runScenario(scenario);
  }

  console.log('\nüèÅ Pruebas de estr√©s frontend finalizadas.');
}

if (require.main === module) {
  main().catch((err) => {
    console.error('‚ùå Error durante las pruebas de estr√©s del frontend:', err);
    process.exitCode = 1;
  });
}

module.exports = { main };